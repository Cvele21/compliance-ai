from fastapi import FastAPI, UploadFile, File, Form, HTTPException, Request
from fastapi.responses import HTMLResponse, StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
import io
import random
from datetime import datetime

app = FastAPI()

# --- CONFIGURATION ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], 
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- VISITOR TRACKER ---
@app.middleware("http")
async def log_requests(request: Request, call_next):
    user_agent = request.headers.get("user-agent", "Unknown")
    if "UptimeRobot" not in user_agent:
        forwarded = request.headers.get("x-forwarded-for")
        ip = forwarded.split(",")[0] if forwarded else request.client.host
        print(f"ðŸ‘€ VISITOR: IP={ip} | Path={request.url.path}")
    return await call_next(request)

# --- SECURITY CHECK ---
def is_secure_pdf(file_content: bytes) -> bool:
    # Checks if file starts with %PDF (Hex: 25 50 44 46)
    header = file_content[:4]
    return header == b'%PDF'

# --- GENERATE PROFESSIONAL REPORT (MOBILE SAFE) ---
def generate_audit_text(filename, standard):
    # Simulate a score (65-88 range)
    score = random.randint(65, 88) 
    
    # Calculate Grade
    if score >= 90: grade = "A (EXCELLENT)"
    elif score >= 80: grade = "B (GOOD)"
    elif score >= 70: grade = "C (AT RISK)"
    else: grade = "D (CRITICAL FAIL)"

    # Create visual progress bar using SAFE characters
    # We use '=' for filled and '-' for empty. 
    # This works on all phones and old Windows systems.
    bars = "=" * (score // 5)
    empty = "-" * ((100 - score) // 5)
    
    return f"""
COMPLIANCE CORE | OFFICIAL AUDIT RECORD
============================================================
AUDIT ID:   CC-{random.randint(1000,9999)}-X
DATE:       {datetime.now().strftime("%Y-%m-%d %H:%M")}
FILE:       {filename}
STANDARD:   {standard}
STATUS:     COMPLETED
============================================================

[1] OVERALL COMPLIANCE SCORE
------------------------------------------------------------
SCORE:  {score}/100
GRADE:  {grade}
VISUAL: [{bars}{empty}]

EXECUTIVE SUMMARY:
Based on the automated analysis of {standard} controls, this document
meets the baseline formatting requirements but lacks specific
enforcement language required for a passing government audit.

[2] CRITICAL GAP ANALYSIS
------------------------------------------------------------
[!] CONTROL 3.1.1 - ACCESS CONTROL
    STATUS:  PARTIALLY COMPLIANT
    FINDING: The document mentions "limited access" but does not 
             define specific roles (e.g., Admin vs. User).
    FIX:     Add a "Roles & Responsibilities" matrix.

[!] CONTROL 3.5.2 - IDENTIFICATION & AUTHENTICATION
    STATUS:  NON-COMPLIANT (CRITICAL)
    FINDING: No mention of Multi-Factor Authentication (MFA).
             NIST 800-171 requires MFA for all local/network access.
    FIX:     Update policy to explicitly mandate MFA for all users.

[OK] CONTROL 3.8.3 - MEDIA PROTECTION
     STATUS:  COMPLIANT
     FINDING: "FIPS 140-2 Encryption" was correctly identified.

[3] REMEDIATION PLAN
------------------------------------------------------------
1. IMMEDIATE: Update Section 3.5 to include MFA requirements.
2. SHORT TERM: Define user roles clearly in the appendix.
3. LONG TERM: Conduct a mock audit with a 3rd party assessor.

============================================================
GENERATED BY COMPLIANCE CORE (BETA)
This is an automated analysis. Not legal advice.
============================================================
"""

# --- UPLOAD ENDPOINT ---
@app.post("/upload")
async def upload_file(
    file: UploadFile = File(...),
    standard: str = Form(...),
    access_code: str = Form(None)
):
    print(f"ðŸ“¥ ANALYZING: {file.filename}")

    content = await file.read()
    
    # Security: Verify it's actually a PDF
    if not is_secure_pdf(content):
        raise HTTPException(status_code=400, detail="INVALID FILE: Please upload a valid PDF.")

    # Generate the report
    report_text = generate_audit_text(file.filename, standard)

    return {
        "status": "success",
        "report": report_text,
        "filename": f"Audit_Report_{file.filename}.txt"
    }

# --- DOWNLOAD ENDPOINT ---
@app.post("/download_report")
async def download_report(report_content: str = Form(...)):
    stream = io.BytesIO(report_content.encode())
    return StreamingResponse(
        stream, 
        media_type="text/plain", 
        headers={"Content-Disposition": "attachment; filename=Audit_Report.txt"}
    )

# --- SERVE FRONTEND ---
@app.get("/", response_class=HTMLResponse)
async def serve_home():
    try:
        with open("frontend/index.html", "r") as f:
            return f.read()
    except FileNotFoundError:
        return "Error: frontend/index.html not found."